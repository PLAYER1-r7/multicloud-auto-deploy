name: Deploy to Azure

on:
  push:
    branches:
      - develop # stagingè‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤
      - main # productionè‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤
    paths:
      - "multicloud-auto-deploy/services/**"
      - "multicloud-auto-deploy/infrastructure/pulumi/azure/**"
      - ".github/workflows/deploy-azure.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production

env:
  AZURE_REGION: japaneast
  NODE_VERSION: "24"
  PYTHON_VERSION: "3.13"

# Prevent concurrent Pulumi updates on the same stack (causes 409 Conflict)
concurrency:
  group: deploy-azure-${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'staging') }}
  cancel-in-progress: false

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    # developâ†’staging, mainâ†’production, æ‰‹å‹•â†’é¸æŠã—ãŸç’°å¢ƒ
    environment: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'staging') }}

    steps:
      - uses: actions/checkout@v4

      # Skip initial Azure Login - use Service Principal env vars for Terraform only
      # - name: Azure Login
      #   uses: azure/login@v1
      #   with:
      #     creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Pulumi CLI
        uses: pulumi/actions@v5

      - name: Install Pulumi Python Dependencies
        run: |
          cd multicloud-auto-deploy/infrastructure/pulumi/azure
          pip install -r requirements.txt

      - name: Determine Pulumi Stack Name
        id: set_stack
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            STACK_NAME="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            STACK_NAME="production"
          else
            STACK_NAME="staging"
          fi
          echo "stack_name=$STACK_NAME" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Using Pulumi stack: $STACK_NAME"

      - name: Initialize Pulumi Stack
        run: |
          cd multicloud-auto-deploy/infrastructure/pulumi/azure
          pulumi login
          pulumi stack select ${{ steps.set_stack.outputs.stack_name }} 2>/dev/null || pulumi stack init ${{ steps.set_stack.outputs.stack_name }}
          pulumi config set azure-native:location japaneast
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Azure Environment Variables
        id: azure_env
        run: |
          echo "subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" >> $GITHUB_OUTPUT
          CREDS='${{ secrets.AZURE_CREDENTIALS }}'
          echo "client_id=$(echo $CREDS | jq -r '.clientId')" >> $GITHUB_OUTPUT
          echo "client_secret=$(echo $CREDS | jq -r '.clientSecret')" >> $GITHUB_OUTPUT
          echo "tenant_id=$(echo $CREDS | jq -r '.tenantId')" >> $GITHUB_OUTPUT

      # Deploy Azure AD resources with Pulumi (Function App remains manual)
      # Azure Portal quota limitations prevent IaC-based App Service Plan creation
      # Function App created manually: multicloud-auto-deploy-staging-func (FC1 Flex Consumption)

      - name: Deploy Infrastructure with Pulumi
        id: pulumi
        uses: pulumi/actions@v5
        with:
          command: up
          stack-name: ${{ steps.set_stack.outputs.stack_name }}
          work-dir: multicloud-auto-deploy/infrastructure/pulumi/azure
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          ARM_CLIENT_ID: ${{ steps.azure_env.outputs.client_id }}
          ARM_CLIENT_SECRET: ${{ steps.azure_env.outputs.client_secret }}
          ARM_TENANT_ID: ${{ steps.azure_env.outputs.tenant_id }}
          ARM_SUBSCRIPTION_ID: ${{ steps.azure_env.outputs.subscription_id }}
          AZURE_STORAGE_ACCOUNT: "" # Required for Pulumi state backend

      - name: Get Pulumi Outputs
        id: pulumi_outputs
        run: |
          cd multicloud-auto-deploy/infrastructure/pulumi/azure

          # Get resource names from Pulumi
          echo "resource_group_name=$(pulumi stack output resource_group_name)" >> $GITHUB_OUTPUT

          # Get Azure AD outputs
          echo "azure_ad_client_id=$(pulumi stack output azure_ad_client_id)" >> $GITHUB_OUTPUT
          echo "azure_ad_object_id=$(pulumi stack output azure_ad_object_id)" >> $GITHUB_OUTPUT

          # Get Cosmos DB outputs
          echo "cosmos_account_name=$(pulumi stack output cosmos_account_name)" >> $GITHUB_OUTPUT
          echo "cosmos_db_endpoint=$(pulumi stack output cosmos_db_endpoint)" >> $GITHUB_OUTPUT
          echo "cosmos_database_name=$(pulumi stack output cosmos_database_name)" >> $GITHUB_OUTPUT
          echo "cosmos_container_name=$(pulumi stack output cosmos_container_name)" >> $GITHUB_OUTPUT

          # Get Front Door hostname for CORS
          echo "frontdoor_hostname=$(pulumi stack output frontdoor_hostname)" >> $GITHUB_OUTPUT

          # Manual Function App reference (not managed by Pulumi)
          # Function App name is environment-specific
          STACK_NAME="${{ steps.set_stack.outputs.stack_name }}"
          FUNC_APP_NAME="multicloud-auto-deploy-${STACK_NAME}-func"
          echo "function_app_name=${FUNC_APP_NAME}" >> $GITHUB_OUTPUT

          # Get storage account names dynamically from Azure (fallback if Pulumi outputs not available)
          RG_NAME=$(pulumi stack output resource_group_name)
          FUNC_STORAGE=$(az storage account list --resource-group $RG_NAME --query "[?contains(name, 'func')].name | [0]" -o tsv)
          WEB_STORAGE=$(az storage account list --resource-group $RG_NAME --query "[?contains(name, 'web')].name | [0]" -o tsv)

          echo "functions_storage_name=${FUNC_STORAGE}" >> $GITHUB_OUTPUT
          echo "frontend_storage_name=${WEB_STORAGE}" >> $GITHUB_OUTPUT

          # Get Function App URL
          FUNC_HOSTNAME=$(az functionapp config hostname list \
            --webapp-name ${FUNC_APP_NAME} \
            --resource-group $RG_NAME \
            --query '[0].name' -o tsv)
          API_URL="https://${FUNC_HOSTNAME}/api/HttpTrigger"
          echo "api_url=${API_URL}" >> $GITHUB_OUTPUT

          echo "ğŸ“ Configured API URL: ${API_URL}"
          echo "ğŸ” Azure AD Client ID: $(pulumi stack output azure_ad_client_id)"
          echo "ğŸ—„ï¸  Cosmos DB Account: $(pulumi stack output cosmos_account_name)"

      - name: Package Function App
        run: |
          cd multicloud-auto-deploy/services/api

          echo "ğŸ“¦ Creating optimized deployment package..."

          # Create deployment directory
          rm -rf .deployment
          mkdir -p .deployment

          # Install dependencies to deployment directory (Azure-specific only)
          echo "Installing Azure-specific dependencies..."
          pip install --target .deployment --no-cache-dir -r requirements-azure.txt

          # Aggressive cleanup of unnecessary files
          echo "Cleaning up unnecessary files..."
          find .deployment -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find .deployment -type d -name "tests" -exec rm -rf {} + 2>/dev/null || true
          find .deployment -type d -name "*.dist-info" -exec rm -rf {} + 2>/dev/null || true
          find .deployment -type d -name "*.egg-info" -exec rm -rf {} + 2>/dev/null || true
          find .deployment -type f -name "*.pyc" -delete 2>/dev/null || true
          find .deployment -type f -name "*.pyo" -delete 2>/dev/null || true
          find .deployment -type f -name "*.so" -delete 2>/dev/null || true

          # Remove test and documentation files
          find .deployment -type f -name "test_*.py" -delete 2>/dev/null || true
          find .deployment -type f -name "*_test.py" -delete 2>/dev/null || true
          find .deployment -type d -name "docs" -exec rm -rf {} + 2>/dev/null || true
          find .deployment -type d -name "examples" -exec rm -rf {} + 2>/dev/null || true

          # Copy application code
          cp -r app .deployment/
          cp function_app.py .deployment/
          cp host.json .deployment/
          cp requirements-azure.txt .deployment/requirements.txt

          # Clean up app __pycache__
          find .deployment/app -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true

          # Create ZIP package with maximum compression
          cd .deployment
          zip -r9 -q ../function-app.zip .
          cd ..

          echo "âœ… Package created:"
          ls -lh function-app.zip
          PACKAGE_SIZE=$(du -h function-app.zip | cut -f1)
          PACKAGE_SIZE_KB=$(du -k function-app.zip | cut -f1)
          echo "ğŸ“¦ Package size: $PACKAGE_SIZE ($PACKAGE_SIZE_KB KB)"

          # Show size breakdown
          echo ""
          echo "ğŸ“Š Top 10 largest items in package:"
          unzip -l function-app.zip | sort -k4 -n -r | head -n 11

      - name: Deploy Function App
        run: |
          FUNCTION_APP="${{ steps.pulumi_outputs.outputs.function_app_name }}"
          RESOURCE_GROUP="${{ steps.pulumi_outputs.outputs.resource_group_name }}"
          COSMOS_ACCOUNT="${{ steps.pulumi_outputs.outputs.cosmos_account_name }}"

          echo "ğŸš€ Deploying to Function App: $FUNCTION_APP"
          echo "ğŸ—„ï¸  Cosmos DB Account: $COSMOS_ACCOUNT"

          # Check for ongoing deployments and wait if necessary
          echo "ğŸ” Checking for ongoing deployments..."
          MAX_WAIT=300  # 5 minutes max wait
          WAIT_COUNT=0
          while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
            # Get deployment status from Kudu API
            DEPLOY_STATUS=$(az rest --method get \
              --url "https://${FUNCTION_APP}.scm.azurewebsites.net/api/deployments/latest" \
              --resource "https://management.azure.com/" \
              --query "status" -o tsv 2>/dev/null || echo "Unknown")
            
            if [ "$DEPLOY_STATUS" = "Running" ] || [ "$DEPLOY_STATUS" = "Building" ]; then
              echo "â³ Deployment in progress (status: $DEPLOY_STATUS), waiting 30s..."
              sleep 30
              WAIT_COUNT=$((WAIT_COUNT+30))
            else
              echo "âœ… No ongoing deployment detected"
              break
            fi
          done

          if [ $WAIT_COUNT -ge $MAX_WAIT ]; then
            echo "âš ï¸  Timeout waiting for previous deployment, proceeding anyway..."
          fi

          sleep 10  # Additional safety buffer

          # Get Cosmos DB endpoint and keys directly from Pulumi outputs
          echo "ğŸ”‘ Getting Cosmos DB credentials from Pulumi outputs..."
          COSMOS_ENDPOINT="${{ steps.pulumi_outputs.outputs.cosmos_db_endpoint }}"
          COSMOS_DATABASE="${{ steps.pulumi_outputs.outputs.cosmos_database_name }}"
          COSMOS_CONTAINER="${{ steps.pulumi_outputs.outputs.cosmos_container_name }}"
          COSMOS_ACCOUNT="${{ steps.pulumi_outputs.outputs.cosmos_account_name }}"

          # Get Cosmos DB key from Azure
          COSMOS_KEY=$(az cosmosdb keys list \
            --name $COSMOS_ACCOUNT \
            --resource-group $RESOURCE_GROUP \
            --type keys \
            --query primaryMasterKey -o tsv)

          if [ -z "$COSMOS_ENDPOINT" ] || [ -z "$COSMOS_KEY" ]; then
            echo "âŒ Failed to retrieve Cosmos DB credentials"
            echo "   Endpoint: $COSMOS_ENDPOINT"
            echo "   Key: ${COSMOS_KEY:0:20}..."
            echo "   Account: $COSMOS_ACCOUNT"
            exit 1
          fi

          echo "âœ… Cosmos DB Account: $COSMOS_ACCOUNT"
          echo "âœ… Cosmos DB Endpoint: $COSMOS_ENDPOINT"

          # Get Front Door URL for CORS from Pulumi outputs
          FRONTDOOR_URL="${{ steps.pulumi_outputs.outputs.frontdoor_hostname }}"
          CORS_ORIGINS="https://${FRONTDOOR_URL},http://localhost:5173"

          echo "ğŸ”’ CORS Origins: $CORS_ORIGINS"

          # Remove existing CORS settings (both uppercase and lowercase)
          echo "ğŸ”§ Removing existing CORS settings if present..."
          az functionapp config appsettings delete \
            --name $FUNCTION_APP \
            --resource-group $RESOURCE_GROUP \
            --setting-names CORS_ORIGINS cors_origins 2>/dev/null || true

          # Wait for delete to propagate
          sleep 3

          # Set environment variables (including Azure AD authentication)
          # Determine environment and auth settings
          DEPLOY_ENV="${{ steps.set_stack.outputs.stack_name }}"
          # Disable auth in staging for testability; keep auth enabled in production
          if [[ "$DEPLOY_ENV" == "staging" ]]; then
            AUTH_DISABLED_VALUE="true"
          else
            AUTH_DISABLED_VALUE="false"
          fi

          echo "âš™ï¸  Setting environment variables (ENVIRONMENT=$DEPLOY_ENV, AUTH_DISABLED=$AUTH_DISABLED_VALUE)..."
          az functionapp config appsettings set \
            --name $FUNCTION_APP \
            --resource-group $RESOURCE_GROUP \
            --settings \
              CLOUD_PROVIDER=azure \
              ENVIRONMENT="${DEPLOY_ENV}" \
              AUTH_DISABLED="${AUTH_DISABLED_VALUE}" \
              COSMOS_DB_ENDPOINT="${COSMOS_ENDPOINT}" \
              COSMOS_DB_KEY="${COSMOS_KEY}" \
              COSMOS_DB_DATABASE="${{ steps.pulumi_outputs.outputs.cosmos_database_name }}" \
              COSMOS_DB_CONTAINER="${{ steps.pulumi_outputs.outputs.cosmos_container_name }}" \
              AUTH_PROVIDER=azure \
              AZURE_TENANT_ID="${{ steps.azure_env.outputs.tenant_id }}" \
              AZURE_CLIENT_ID="${{ steps.pulumi_outputs.outputs.azure_ad_client_id }}" \
              CORS_ORIGINS="${CORS_ORIGINS}" \
            > /dev/null

          echo "ğŸ” Azure AD Authentication configured:"
          echo "  Tenant ID: ${{ steps.azure_env.outputs.tenant_id }}"
          echo "  Client ID: ${{ steps.pulumi_outputs.outputs.azure_ad_client_id }}"
          echo "ğŸ—„ï¸  Cosmos DB configured:"
          echo "  Database: ${{ steps.pulumi_outputs.outputs.cosmos_database_name }}"
          echo "  Container: ${{ steps.pulumi_outputs.outputs.cosmos_container_name }}"

          echo "ğŸ“¦ Deploying function app package (with retry logic)..."

          # Retry deployment up to 3 times to handle Kudu restarts
          MAX_RETRIES=3
          RETRY_COUNT=0
          DEPLOY_SUCCESS=false

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Attempt $((RETRY_COUNT+1))/$MAX_RETRIES..."
            
            # Run deployment and capture output
            az functionapp deployment source config-zip \
              --resource-group $RESOURCE_GROUP \
              --name $FUNCTION_APP \
              --src multicloud-auto-deploy/services/api/function-app.zip \
              --timeout 600 \
              2>&1 | tee deploy_log.txt || true
            
            # Check for "another deployment in progress" error (retry with longer wait)
            if grep -q "another deployment is in progress" deploy_log.txt; then
              echo "â³ Another deployment in progress, waiting 60s before retry..."
              RETRY_COUNT=$((RETRY_COUNT+1))
              sleep 60
              continue
            fi
            
            # Check for Kudu restart
            if grep -q "Kudu has been restarted" deploy_log.txt; then
              echo "ğŸ”„ Kudu restart detected, retrying..."
              RETRY_COUNT=$((RETRY_COUNT+1))
              sleep 30
              continue
            fi
            
            # Check for successful deployment (in order of reliability)
            # 1. Explicit success message (most reliable for Flex Consumption)
            if grep -q "Deployment was successful" deploy_log.txt; then
              echo "âœ… Deployment successful!"
              DEPLOY_SUCCESS=true
              break
            # 2. Deployment steps completed (for other plan types)
            elif grep -q "UploadPackageStep.*completed" deploy_log.txt || \
                 grep -q "SyncTriggerStep" deploy_log.txt; then
              echo "âœ… Deployment steps completed!"
              DEPLOY_SUCCESS=true
              break
            # 3. Critical error (but not "partially successful" or "in progress")
            elif grep -q "ERROR:" deploy_log.txt && \
                 ! grep -q "partially successful" deploy_log.txt && \
                 ! grep -q "another deployment is in progress" deploy_log.txt; then
              echo "âŒ Critical deployment error"
              cat deploy_log.txt
              exit 1
            else
              echo "âš ï¸  Deployment status unclear, retrying..."
              RETRY_COUNT=$((RETRY_COUNT+1))
              sleep 30
            fi
          done

          if [ "$DEPLOY_SUCCESS" = false ]; then
            echo "âš ï¸  Deployment uncertain after $MAX_RETRIES attempts, checking function health..."
          else
            echo "âœ… Deployment completed successfully!"
          fi

      - name: Build Frontend
        run: |
          cd multicloud-auto-deploy/services/frontend_react

          API_URL="${{ steps.pulumi_outputs.outputs.api_url }}"
          echo "ğŸ”§ Building frontend with API_URL: $API_URL"

          npm install
          npm run build

          # Verify the API URL was embedded
          echo "ğŸ” Verifying built assets..."
          grep -r "multicloud-auto-deploy-staging-func" dist/ || echo "âš ï¸ API URL not found in build - check VITE_API_URL"
        env:
          VITE_API_URL: ${{ steps.pulumi_outputs.outputs.api_url }}

      - name: Enable Static Website Hosting
        run: |
          STORAGE_ACCOUNT="${{ steps.pulumi_outputs.outputs.frontend_storage_name }}"
          RESOURCE_GROUP="${{ steps.pulumi_outputs.outputs.resource_group_name }}"

          echo "ğŸŒ Enabling static website hosting on $STORAGE_ACCOUNT..."

          # Get storage account key
          STORAGE_KEY=$(az storage account keys list \
            --resource-group $RESOURCE_GROUP \
            --account-name $STORAGE_ACCOUNT \
            --query '[0].value' -o tsv)

          az storage blob service-properties update \
            --account-name $STORAGE_ACCOUNT \
            --account-key $STORAGE_KEY \
            --static-website \
            --index-document index.html \
            --404-document index.html

      - name: Deploy Frontend to Storage
        run: |
          # Use storage account from Pulumi output
          STORAGE_ACCOUNT="${{ steps.pulumi_outputs.outputs.frontend_storage_name }}"
          RESOURCE_GROUP="${{ steps.pulumi_outputs.outputs.resource_group_name }}"

          # Get storage account key
          STORAGE_KEY=$(az storage account keys list \
            --resource-group $RESOURCE_GROUP \
            --account-name $STORAGE_ACCOUNT \
            --query '[0].value' -o tsv)

          # Upload frontend to blob storage
          az storage blob upload-batch \
            --account-name $STORAGE_ACCOUNT \
            --account-key $STORAGE_KEY \
            --source multicloud-auto-deploy/services/frontend_react/dist \
            --destination '$web' \
            --overwrite

      - name: Verify Deployment
        run: |
          FUNCTION_APP="${{ steps.pulumi_outputs.outputs.function_app_name }}"
          RESOURCE_GROUP="${{ steps.pulumi_outputs.outputs.resource_group_name }}"

          echo "ğŸ” Verifying API deployment..."
          echo "Getting Function App hostname..."

          # Get hostname - for Flex Consumption plan, use config hostname list
          # (defaultHostName is not reliable for Flex Consumption SKU)
          max_hostname_attempts=10
          hostname_attempt=0
          FUNC_HOSTNAME=""

          while [ $hostname_attempt -lt $max_hostname_attempts ]; do
            FUNC_HOSTNAME=$(az functionapp config hostname list \
              --webapp-name $FUNCTION_APP \
              --resource-group $RESOURCE_GROUP \
              --query '[0].name' -o tsv 2>/dev/null || echo "")
            
            if [ -n "$FUNC_HOSTNAME" ] && [ "$FUNC_HOSTNAME" != "None" ]; then
              echo "âœ… Got hostname: $FUNC_HOSTNAME"
              break
            else
              echo "â³ Waiting for Function App to be ready... (attempt $((hostname_attempt+1))/$max_hostname_attempts)"
              sleep 10
              hostname_attempt=$((hostname_attempt+1))
            fi
          done

          if [ -z "$FUNC_HOSTNAME" ] || [ "$FUNC_HOSTNAME" = "None" ]; then
            echo "âŒ Failed to get Function App hostname after waiting"
            echo "Try checking manually: az functionapp config hostname list --webapp-name $FUNCTION_APP --resource-group $RESOURCE_GROUP"
            exit 1
          fi

          FUNC_URL="https://${FUNC_HOSTNAME}/api/HttpTrigger"
          echo "Testing: ${FUNC_URL}/health"

          # Wait for function to be ready (max 3 minutes)
          max_attempts=36
          attempt=0
          health_check_passed=false

          while [ $attempt -lt $max_attempts ]; do
            if response=$(curl -sf "${FUNC_URL}/health" 2>&1); then
              echo "âœ… API is responding!"
              echo "$response" | jq .
              health_check_passed=true
              break
            else
              echo "â³ Waiting for function to be ready... (attempt $((attempt+1))/$max_attempts)"
              sleep 5
              attempt=$((attempt+1))
            fi
          done

          if [ "$health_check_passed" = true ]; then
            echo ""
            echo "âœ… Azure Function deployment verified successfully!"
            echo "ğŸ“ API URL: ${FUNC_URL}"
          else
            echo ""
            echo "âŒ Health check failed after waiting for $((max_attempts * 5)) seconds"
            echo "This may be a transient issue. Check manually: ${FUNC_URL}/health"
            exit 1
          fi

      - name: Notify Success
        if: success()
        run: |
          echo "âœ… Azure deployment succeeded!"
          echo "ğŸ“ API URL: ${{ steps.pulumi_outputs.outputs.api_url }}"
          echo "ğŸŒ Frontend Storage: ${{ steps.pulumi_outputs.outputs.frontend_storage_name }}"

      - name: Notify Failure
        if: failure()
        run: echo "âŒ Azure deployment failed!"
