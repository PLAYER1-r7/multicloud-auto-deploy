name: Deploy to AWS

on:
  push:
    branches:
      - develop # stagingè‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤
      - main # productionè‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤
    paths:
      - "services/**"
      - "infrastructure/pulumi/aws/**"
      - ".github/workflows/deploy-aws.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production

env:
  AWS_REGION: ap-northeast-1
  NODE_VERSION: "24"
  PYTHON_VERSION: "3.13"

# Prevent concurrent Pulumi updates on the same stack (causes ResourceConflictException)
concurrency:
  group: deploy-aws-${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'staging') }}
  cancel-in-progress: false

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    # developâ†’staging, mainâ†’production, æ‰‹å‹•â†’é¸æŠã—ãŸç’°å¢ƒ
    environment: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'staging') }}

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Pulumi CLI
        uses: pulumi/actions@v5

      - name: Install Pulumi Python Dependencies
        run: |
          cd infrastructure/pulumi/aws
          pip install -r requirements.txt

      - name: Determine Pulumi Stack Name
        id: set_stack
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            STACK_NAME="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            STACK_NAME="production"
          else
            STACK_NAME="staging"
          fi
          echo "stack_name=$STACK_NAME" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Using Pulumi stack: $STACK_NAME"

      - name: Initialize Pulumi Stack
        run: |
          cd infrastructure/pulumi/aws
          pulumi login
          pulumi stack select ${{ steps.set_stack.outputs.stack_name }} 2>/dev/null || pulumi stack init ${{ steps.set_stack.outputs.stack_name }}
          pulumi config set aws:region ${{ env.AWS_REGION }}
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}

      - name: Sync Pulumi Config (custom domain + ACM cert)
        run: |
          cd infrastructure/pulumi/aws
          # Pulumi.staging.yaml is gitignored â€” inject custom domain configs from
          # GitHub Secrets so Pulumi includes staging.aws.ashnova.jp in Cognito
          # callback URLs and adds the ACM alias to CloudFront on every run.
          CUSTOM_DOMAIN="${{ secrets.AWS_CUSTOM_DOMAIN }}"
          ACM_CERT_ARN="${{ secrets.AWS_ACM_CERTIFICATE_ARN }}"
          CF_DOMAIN="${{ secrets.AWS_CLOUDFRONT_DOMAIN }}"
          if [ -n "$CUSTOM_DOMAIN" ]; then
            echo "âœ… Setting customDomain = $CUSTOM_DOMAIN"
            pulumi config set multicloud-auto-deploy-aws:customDomain "$CUSTOM_DOMAIN"
          else
            echo "âš ï¸  AWS_CUSTOM_DOMAIN secret not set â€” skipping customDomain config"
          fi
          if [ -n "$ACM_CERT_ARN" ]; then
            echo "âœ… Setting acmCertificateArn"
            pulumi config set multicloud-auto-deploy-aws:acmCertificateArn "$ACM_CERT_ARN"
          else
            echo "âš ï¸  AWS_ACM_CERTIFICATE_ARN secret not set â€” skipping acmCertificateArn config"
          fi
          if [ -n "$CF_DOMAIN" ]; then
            echo "âœ… Setting cloudFrontDomain = $CF_DOMAIN"
            pulumi config set multicloud-auto-deploy-aws:cloudFrontDomain "$CF_DOMAIN"
          else
            echo "âš ï¸  AWS_CLOUDFRONT_DOMAIN secret not set â€” skipping cloudFrontDomain config"
          fi
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Remove stuck obsolete resources from Pulumi state
        run: |
          cd infrastructure/pulumi/aws
          STACK="${{ steps.set_stack.outputs.stack_name }}"
          # These landing-* resources were removed from code but remain in state.
          # Pulumi tries to delete them on every up, but fails:
          #   landing-oai: IAM permission denied (cloudfront:DeleteCloudFrontOriginAccessIdentity)
          #   landing-bucket: BucketNotEmpty
          # Removing from state retains AWS resources but stops Pulumi tracking them.
          pulumi state delete \
            "urn:pulumi:${STACK}::multicloud-auto-deploy-aws::aws:cloudfront/originAccessIdentity:OriginAccessIdentity::landing-oai" \
            --force --yes 2>/dev/null || echo "landing-oai not in state"
          pulumi state delete \
            "urn:pulumi:${STACK}::multicloud-auto-deploy-aws::aws:s3/bucket:Bucket::landing-bucket" \
            --force --yes 2>/dev/null || echo "landing-bucket not in state"
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Deploy Infrastructure with Pulumi
        id: pulumi
        uses: pulumi/actions@v5
        with:
          command: up
          stack-name: ${{ steps.set_stack.outputs.stack_name }}
          work-dir: infrastructure/pulumi/aws
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Get Pulumi Outputs
        id: pulumi_outputs
        run: |
          cd infrastructure/pulumi/aws
          echo "lambda_function_name=$(pulumi stack output lambda_function_name)" >> $GITHUB_OUTPUT
          echo "api_gateway_endpoint=$(pulumi stack output api_gateway_endpoint)" >> $GITHUB_OUTPUT
          echo "frontend_bucket_name=$(pulumi stack output frontend_bucket_name)" >> $GITHUB_OUTPUT
          echo "cloudfront_domain=$(pulumi stack output cloudfront_domain)" >> $GITHUB_OUTPUT
          echo "cloudfront_distribution_id=$(pulumi stack output cloudfront_distribution_id)" >> $GITHUB_OUTPUT
          echo "custom_domain=$(pulumi stack output custom_domain 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "cognito_user_pool_id=$(pulumi stack output cognito_user_pool_id)" >> $GITHUB_OUTPUT
          echo "cognito_client_id=$(pulumi stack output cognito_client_id)" >> $GITHUB_OUTPUT
          echo "cognito_domain=$(pulumi stack output cognito_domain)" >> $GITHUB_OUTPUT
          echo "posts_table_name=$(pulumi stack output posts_table_name)" >> $GITHUB_OUTPUT
          echo "images_bucket_name=$(pulumi stack output images_bucket_name)" >> $GITHUB_OUTPUT
          echo "secret_name=$(pulumi stack output secret_name)" >> $GITHUB_OUTPUT

      - name: Build and Deploy Frontend
        run: |
          FRONTEND_BUCKET="${{ steps.pulumi_outputs.outputs.frontend_bucket_name }}"
          CLOUDFRONT_ID="${{ steps.pulumi_outputs.outputs.cloudfront_distribution_id }}"
          COGNITO_DOMAIN="${{ steps.pulumi_outputs.outputs.cognito_domain }}"
          COGNITO_CLIENT_ID="${{ steps.pulumi_outputs.outputs.cognito_client_id }}"
          API_URL="${{ steps.pulumi_outputs.outputs.api_gateway_endpoint }}"
          CLOUDFRONT_DOMAIN="${{ steps.pulumi_outputs.outputs.cloudfront_domain }}"
          CUSTOM_DOMAIN="${{ steps.pulumi_outputs.outputs.custom_domain }}"

          # Determine the public URL (prefer custom domain if set)
          if [[ -n "$CUSTOM_DOMAIN" ]]; then
            PUBLIC_ORIGIN="https://${CUSTOM_DOMAIN}"
          else
            PUBLIC_ORIGIN="https://${CLOUDFRONT_DOMAIN}"
          fi

          echo "ğŸ—ï¸  Building React frontend for AWS (Cognito auth)..."
          cd services/frontend_react

          npm ci --prefer-offline

          VITE_AUTH_PROVIDER=aws \
          VITE_API_URL="${API_URL}" \
          VITE_COGNITO_DOMAIN="${COGNITO_DOMAIN}.auth.${{ env.AWS_REGION }}.amazoncognito.com" \
          VITE_COGNITO_CLIENT_ID="${COGNITO_CLIENT_ID}" \
          VITE_COGNITO_REDIRECT_URI="${PUBLIC_ORIGIN}/sns/auth/callback" \
          VITE_COGNITO_LOGOUT_URI="${PUBLIC_ORIGIN}/sns/" \
          VITE_BASE_PATH=/sns/ \
          npm run build

          echo "âœ… Frontend build complete. Uploading to S3..."
          cd ../..

          # Upload to S3 at sns/ prefix (CloudFront /sns* path pattern points here)
          aws s3 sync services/frontend_react/dist/ "s3://${FRONTEND_BUCKET}/sns/" \
            --delete \
            --region ${{ env.AWS_REGION }}

          # Invalidate CloudFront cache for sns/ paths
          aws cloudfront create-invalidation \
            --distribution-id $CLOUDFRONT_ID \
            --paths "/sns/*" \
            --region us-east-1

          echo "âœ… Frontend deployed to S3 and CloudFront cache invalidated"
          echo "ğŸŒ Frontend URL: ${PUBLIC_ORIGIN}/sns/"

      - name: Build Lambda Layer
        id: build_layer
        run: |
          cd services/api
          rm -rf .build-layer lambda-layer.zip

          # Build Lambda Layer (dependencies only)
          echo "ğŸ“¦ Building Lambda Layer (dependencies)..."
          bash ../../scripts/build-lambda-layer.sh

          # Show layer info
          echo "âœ… Layer package created:"
          ls -lh lambda-layer.zip

      - name: Package Backend (Application Code Only)
        run: |
          cd services/api
          rm -rf .build lambda.zip
          mkdir -p .build/package

          # Copy application code only (no dependencies - they're in the Layer)
          echo "ğŸ“ Copying application code..."
          cp -r app .build/package/
          cp index.py .build/package/

          # Create zip (application code only - lightweight!)
          echo "ğŸ—œï¸  Creating lambda package (code only)..."
          cd .build/package
          zip -r ../../lambda.zip .
          cd ../..

          # Show package info
          echo "âœ… Package created:"
          ls -lh lambda.zip
          SIZE_MB=$(du -m lambda.zip | cut -f1)
          echo "ğŸ“Š Package size: ${SIZE_MB}MB"

          if [ $SIZE_MB -lt 50 ]; then
            echo "âœ… Package is under 50MB - direct upload possible!"
            echo "use_direct_upload=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸  Package exceeds 50MB - will use S3"
            echo "use_direct_upload=false" >> $GITHUB_OUTPUT
          fi

      - name: Deploy Lambda Layer
        id: deploy_layer
        run: |
          set -e

          LAYER_NAME="multicloud-auto-deploy-${{ github.event.inputs.environment || 'staging' }}-dependencies"

          echo "ğŸš€ Publishing Custom Lambda Layer: $LAYER_NAME"
          LAYER_VERSION_ARN=$(aws lambda publish-layer-version \
            --layer-name $LAYER_NAME \
            --description "Dependencies for FastAPI + Mangum + JWT (Python 3.13)" \
            --zip-file fileb://services/api/lambda-layer.zip \
            --compatible-runtimes python3.13 \
            --region ${{ env.AWS_REGION }} \
            --query LayerVersionArn \
            --output text)

          echo "âœ… Layer published: $LAYER_VERSION_ARN"
          echo "layer_arn=$LAYER_VERSION_ARN" >> $GITHUB_OUTPUT

      - name: Update Lambda Function
        id: update_lambda
        run: |
          set -e
          LAMBDA_FUNCTION="${{ steps.pulumi_outputs.outputs.lambda_function_name }}"

          # Use custom Lambda Layer (optimized, no Klayers)
          echo "ğŸ”§ Using custom Lambda Layer"
          LAYER_ARNS="${{ steps.deploy_layer.outputs.layer_arn }}"

          # Wait for any Pulumi-triggered updates to complete before touching this Lambda
          # (Pulumi up just ran and may have updated the Lambda's environment/configuration)
          echo "â³ Waiting for Lambda to be ready (Pulumi may still be updating it)..."
          aws lambda wait function-updated \
            --function-name $LAMBDA_FUNCTION \
            --region ${{ env.AWS_REGION }}
          echo "âœ… Lambda ready"

          # Debug: Check lambda.zip exists and show size
          echo "ğŸ“¦ Checking lambda.zip..."
          ls -lh services/api/lambda.zip || { echo "âŒ lambda.zip not found!"; exit 1; }

          SIZE_MB=$(du -m services/api/lambda.zip | cut -f1)

          if [ $SIZE_MB -lt 50 ]; then
            # Direct upload (faster!)
            echo "ğŸš€ Direct upload to Lambda (${SIZE_MB}MB < 50MB)"
            aws lambda update-function-code \
              --function-name $LAMBDA_FUNCTION \
              --region ${{ env.AWS_REGION }} \
              --zip-file fileb://services/api/lambda.zip \
              --output json || { echo "âŒ Lambda update failed!"; exit 1; }
          else
            # S3 upload for large packages
            S3_BUCKET="${{ steps.pulumi_outputs.outputs.frontend_bucket_name }}"
            S3_KEY="lambda-deployments/lambda-$(date +%Y%m%d-%H%M%S).zip"
            
            echo "â˜ï¸  Uploading to S3: s3://$S3_BUCKET/$S3_KEY"
            aws s3 cp services/api/lambda.zip s3://$S3_BUCKET/$S3_KEY || { echo "âŒ S3 upload failed!"; exit 1; }
            
            echo "ğŸš€ Updating Lambda from S3"
            aws lambda update-function-code \
              --function-name $LAMBDA_FUNCTION \
              --region ${{ env.AWS_REGION }} \
              --s3-bucket $S3_BUCKET \
              --s3-key $S3_KEY \
              --output json || { echo "âŒ Lambda update failed!"; exit 1; }
          fi

          # Wait for code update to complete before modifying configuration
          echo "â³ Waiting for Lambda code update to stabilize..."
          aws lambda wait function-updated \
            --function-name $LAMBDA_FUNCTION \
            --region ${{ env.AWS_REGION }}
          echo "âœ… Lambda ready for configuration update"

          # Get CloudFront domain for CORS
          CLOUDFRONT_DOMAIN="${{ steps.pulumi_outputs.outputs.cloudfront_domain }}"
          CUSTOM_DOMAIN="${{ steps.pulumi_outputs.outputs.custom_domain }}"
          # Include custom domain in CORS if set
          if [[ -n "$CUSTOM_DOMAIN" ]]; then
            CORS_ORIGINS="https://${CLOUDFRONT_DOMAIN},https://${CUSTOM_DOMAIN},http://localhost:5173"
          else
            CORS_ORIGINS="https://${CLOUDFRONT_DOMAIN},http://localhost:5173"
          fi

          echo "ğŸ”’ CORS Origins: $CORS_ORIGINS"

          # Create environment variables JSON to avoid escaping issues
          USER_POOL_ID="${{ steps.pulumi_outputs.outputs.cognito_user_pool_id }}"
          CLIENT_ID="${{ steps.pulumi_outputs.outputs.cognito_client_id }}"
          POSTS_TABLE="${{ steps.pulumi_outputs.outputs.posts_table_name }}"
          IMAGES_BUCKET="${{ steps.pulumi_outputs.outputs.images_bucket_name }}"
          SECRET_NAME="${{ steps.pulumi_outputs.outputs.secret_name }}"

          # Determine environment and auth settings
          DEPLOY_ENV="${{ steps.set_stack.outputs.stack_name }}"
          # Auth is always enabled: Cognito is configured for both staging and production.
          AUTH_DISABLED_VALUE="false"

          echo '{' > /tmp/lambda-env.json
          echo '  "Variables": {' >> /tmp/lambda-env.json
          echo '    "CLOUD_PROVIDER": "aws",' >> /tmp/lambda-env.json
          echo "    \"ENVIRONMENT\": \"$DEPLOY_ENV\"," >> /tmp/lambda-env.json
          echo "    \"AUTH_DISABLED\": \"$AUTH_DISABLED_VALUE\"," >> /tmp/lambda-env.json
          echo '    "AUTH_PROVIDER": "cognito",' >> /tmp/lambda-env.json
          echo "    \"AWS_COGNITO_USER_POOL_ID\": \"$USER_POOL_ID\"," >> /tmp/lambda-env.json
          echo "    \"AWS_COGNITO_CLIENT_ID\": \"$CLIENT_ID\"," >> /tmp/lambda-env.json
          echo "    \"COGNITO_REGION\": \"${{ env.AWS_REGION }}\"," >> /tmp/lambda-env.json
          echo "    \"POSTS_TABLE_NAME\": \"$POSTS_TABLE\"," >> /tmp/lambda-env.json
          echo "    \"IMAGES_BUCKET_NAME\": \"$IMAGES_BUCKET\"," >> /tmp/lambda-env.json
          echo "    \"SECRET_NAME\": \"$SECRET_NAME\"," >> /tmp/lambda-env.json
          echo "    \"CORS_ORIGINS\": \"$CORS_ORIGINS\"" >> /tmp/lambda-env.json
          echo '  }' >> /tmp/lambda-env.json
          echo '}' >> /tmp/lambda-env.json

          # Update configuration with environment variables and Layer(s)
          echo "ğŸ”— Updating Lambda configuration..."
          aws lambda update-function-configuration \
            --function-name $LAMBDA_FUNCTION \
            --region ${{ env.AWS_REGION }} \
            --layers $LAYER_ARNS \
            --environment file:///tmp/lambda-env.json \
            --output json || { echo "âŒ Lambda configuration update failed!"; exit 1; }

          echo "âœ… Lambda function updated successfully with Layer(s) and environment variables"
          echo "api_endpoint=${{ steps.pulumi_outputs.outputs.api_gateway_endpoint }}" >> $GITHUB_OUTPUT

      - name: Notify Success
        if: success()
        run: |
          echo "âœ… AWS deployment succeeded!"
          echo "ğŸ“ API Endpoint: ${{ steps.pulumi_outputs.outputs.api_gateway_endpoint }}"
          echo "ğŸŒ Frontend: https://${{ steps.pulumi_outputs.outputs.cloudfront_domain }}/sns/"

      - name: Notify Failure
        if: failure()
        run: echo "âŒ AWS deployment failed!"
