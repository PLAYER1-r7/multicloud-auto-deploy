name: Deploy to Azure

on:
  push:
    branches:
      - develop # stagingËá™Âãï„Éá„Éó„É≠„Ç§
      - main # productionËá™Âãï„Éá„Éó„É≠„Ç§
    paths:
      - "services/**"
      - "infrastructure/pulumi/azure/**"
      - ".github/workflows/deploy-azure.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production

env:
  AZURE_REGION: japaneast
  NODE_VERSION: "24"
  PYTHON_VERSION: "3.13"

# Prevent concurrent Pulumi updates on the same stack (causes 409 Conflict)
concurrency:
  group: deploy-azure-${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'staging') }}
  cancel-in-progress: false

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    # develop‚Üístaging, main‚Üíproduction, ÊâãÂãï‚ÜíÈÅ∏Êäû„Åó„ÅüÁí∞Â¢É
    environment: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'staging') }}

    steps:
      - uses: actions/checkout@v4

      # Skip initial Azure Login - use Service Principal env vars for Terraform only
      # - name: Azure Login
      #   uses: azure/login@v1
      #   with:
      #     creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Pulumi CLI
        uses: pulumi/actions@v5

      - name: Install Pulumi Python Dependencies
        run: |
          cd infrastructure/pulumi/azure
          pip install -r requirements.txt

      - name: Determine Pulumi Stack Name
        id: set_stack
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            STACK_NAME="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            STACK_NAME="production"
          else
            STACK_NAME="staging"
          fi
          echo "stack_name=$STACK_NAME" >> $GITHUB_OUTPUT
          echo "üì¶ Using Pulumi stack: $STACK_NAME"

      - name: Initialize Pulumi Stack
        run: |
          cd infrastructure/pulumi/azure
          pulumi login
          pulumi stack select ${{ steps.set_stack.outputs.stack_name }} 2>/dev/null || pulumi stack init ${{ steps.set_stack.outputs.stack_name }}
          pulumi config set azure-native:location japaneast
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Azure Environment Variables
        id: azure_env
        run: |
          echo "subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" >> $GITHUB_OUTPUT
          CREDS='${{ secrets.AZURE_CREDENTIALS }}'
          echo "client_id=$(echo $CREDS | jq -r '.clientId')" >> $GITHUB_OUTPUT
          echo "client_secret=$(echo $CREDS | jq -r '.clientSecret')" >> $GITHUB_OUTPUT
          echo "tenant_id=$(echo $CREDS | jq -r '.tenantId')" >> $GITHUB_OUTPUT

      # Deploy Azure AD resources with Pulumi (Function App remains manual)
      # Azure Portal quota limitations prevent IaC-based App Service Plan creation
      # Function App created manually: multicloud-auto-deploy-staging-func (FC1 Flex Consumption)

      - name: Cancel any pending Pulumi operations
        run: |
          cd infrastructure/pulumi/azure
          # Cancel any in-progress update
          pulumi cancel --yes 2>/dev/null || true
          # Clear any leftover pending operations from interrupted deployments
          pulumi stack export > /tmp/pulumi-state.json 2>/dev/null || true
          if jq -e '.deployment.pending_operations | length > 0' /tmp/pulumi-state.json > /dev/null 2>&1; then
            echo "Found pending operations - clearing..."
            jq '.deployment.pending_operations = []' /tmp/pulumi-state.json > /tmp/pulumi-state-clean.json
            pulumi stack import --force < /tmp/pulumi-state-clean.json
            echo "Pending operations cleared"
          else
            echo "No pending operations found"
          fi
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}

      - name: Sync Pulumi Config (frontendDomain)
        run: |
          cd infrastructure/pulumi/azure
          # Set frontendDomain in Pulumi config so Azure AD app registration
          # gets the correct redirect URI for the Front Door endpoint.
          # On first deploy (no FD yet), this is a no-op and re-run will fix it.
          FRONTDOOR=$(pulumi stack output frontdoor_hostname 2>/dev/null || echo "")
          if [ -n "$FRONTDOOR" ] && [ "$FRONTDOOR" != "None" ]; then
            echo "‚úÖ Setting frontendDomain = $FRONTDOOR"
            pulumi config set frontendDomain "$FRONTDOOR"
          else
            echo "‚ÑπÔ∏è  No existing frontdoor_hostname in stack state ‚Äî skipping frontendDomain config"
          fi
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          ARM_CLIENT_ID: ${{ steps.azure_env.outputs.client_id }}
          ARM_CLIENT_SECRET: ${{ steps.azure_env.outputs.client_secret }}
          ARM_TENANT_ID: ${{ steps.azure_env.outputs.tenant_id }}
          ARM_SUBSCRIPTION_ID: ${{ steps.azure_env.outputs.subscription_id }}

      - name: Deploy Infrastructure with Pulumi
        id: pulumi
        uses: pulumi/actions@v5
        with:
          command: up
          stack-name: ${{ steps.set_stack.outputs.stack_name }}
          work-dir: infrastructure/pulumi/azure
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          ARM_CLIENT_ID: ${{ steps.azure_env.outputs.client_id }}
          ARM_CLIENT_SECRET: ${{ steps.azure_env.outputs.client_secret }}
          ARM_TENANT_ID: ${{ steps.azure_env.outputs.tenant_id }}
          ARM_SUBSCRIPTION_ID: ${{ steps.azure_env.outputs.subscription_id }}
          AZURE_STORAGE_ACCOUNT: "" # Required for Pulumi state backend

      - name: Get Pulumi Outputs
        id: pulumi_outputs
        run: |
          cd infrastructure/pulumi/azure

          # Get resource names from Pulumi
          echo "resource_group_name=$(pulumi stack output resource_group_name)" >> $GITHUB_OUTPUT

          # Get Azure AD outputs
          echo "azure_ad_client_id=$(pulumi stack output azure_ad_client_id)" >> $GITHUB_OUTPUT
          echo "azure_ad_object_id=$(pulumi stack output azure_ad_object_id)" >> $GITHUB_OUTPUT

          # Get Cosmos DB outputs
          echo "cosmos_account_name=$(pulumi stack output cosmos_account_name)" >> $GITHUB_OUTPUT
          echo "cosmos_db_endpoint=$(pulumi stack output cosmos_db_endpoint)" >> $GITHUB_OUTPUT
          echo "cosmos_database_name=$(pulumi stack output cosmos_database_name)" >> $GITHUB_OUTPUT
          echo "cosmos_container_name=$(pulumi stack output cosmos_container_name)" >> $GITHUB_OUTPUT

          # Get Front Door hostname for CORS
          echo "frontdoor_hostname=$(pulumi stack output frontdoor_hostname)" >> $GITHUB_OUTPUT

          # Manual Function App reference (not managed by Pulumi)
          # Function App name is environment-specific
          STACK_NAME="${{ steps.set_stack.outputs.stack_name }}"
          FUNC_APP_NAME="multicloud-auto-deploy-${STACK_NAME}-func"
          echo "function_app_name=${FUNC_APP_NAME}" >> $GITHUB_OUTPUT

          # Get storage account names directly from Pulumi outputs
          # (Azure CLI query "contains(name, 'web')" matches multiple accounts and may pick wrong one)
          echo "frontend_storage_name=$(pulumi stack output frontend_storage_name)" >> $GITHUB_OUTPUT
          echo "functions_storage_name=$(pulumi stack output functions_storage_name)" >> $GITHUB_OUTPUT

          # Get Function App URL
          FUNC_HOSTNAME=$(az functionapp config hostname list \
            --webapp-name ${FUNC_APP_NAME} \
            --resource-group $RG_NAME \
            --query '[0].name' -o tsv)
          API_URL="https://${FUNC_HOSTNAME}/api/HttpTrigger"
          echo "api_url=${API_URL}" >> $GITHUB_OUTPUT

          echo "üìç Configured API URL: ${API_URL}"
          echo "üîê Azure AD Client ID: $(pulumi stack output azure_ad_client_id)"
          echo "üóÑÔ∏è  Cosmos DB Account: $(pulumi stack output cosmos_account_name)"

      - name: Update Azure AD App Redirect URIs
        # Ensures ALL required redirect URIs are registered (login callbacks + post-logout redirects).
        # Pulumi only manages FrontDoor-based URIs; custom domain and /sns/ logout URIs are added here.
        run: |
          AD_APP_ID="${{ steps.pulumi_outputs.outputs.azure_ad_client_id }}"
          FRONTDOOR="${{ steps.pulumi_outputs.outputs.frontdoor_hostname }}"
          AZURE_CUSTOM_DOMAIN="${{ secrets.AZURE_CUSTOM_DOMAIN }}"

          # Build redirect URI list: login callbacks (/sns/auth/callback) + logout redirects (/sns/)
          URIS=(
            "http://localhost:3000/callback"
            "https://localhost:3000/callback"
            "http://localhost:5173/sns/auth/callback"
            "https://localhost:5173/sns/auth/callback"
            "http://localhost:5173/sns/"
          )

          # Add FrontDoor URIs
          if [ -n "$FRONTDOOR" ]; then
            URIS+=("https://${FRONTDOOR}/sns/auth/callback")
            URIS+=("https://${FRONTDOOR}/sns/")
          fi

          # Add custom domain URIs
          if [ -n "$AZURE_CUSTOM_DOMAIN" ]; then
            URIS+=("https://${AZURE_CUSTOM_DOMAIN}/sns/auth/callback")
            URIS+=("https://${AZURE_CUSTOM_DOMAIN}/sns/")
          fi

          echo "üîê Registering redirect URIs on Azure AD App (${AD_APP_ID}):"
          for uri in "${URIS[@]}"; do echo "   $uri"; done

          az ad app update --id "$AD_APP_ID" --web-redirect-uris "${URIS[@]}"
          echo "‚úÖ Azure AD redirect URIs updated"
        run: |
          cd services/api

          echo "üì¶ Creating optimized deployment package..."

          # Create deployment directory
          rm -rf .deployment
          mkdir -p .deployment

          # Install dependencies using Docker with the EXACT same platform/Python as Azure Functions
          # Azure Functions Flex Consumption uses Python 3.11 on linux/amd64.
          # The GitHub Actions runner may be a different arch (e.g., arm64), so using the runner's
          # native pip would produce wrong .so binaries (e.g., cpython-312-aarch64 instead of
          # cpython-311-x86_64). Docker ensures correct platform + Python version.
          echo "Installing Azure-specific dependencies (linux/amd64 python:3.11)..."
          docker run --rm --platform linux/amd64 \
            -v "$(pwd):/work" \
            python:3.11-slim \
            pip install --target /work/.deployment --no-cache-dir -q \
              -r /work/requirements-azure.txt

          # Aggressive cleanup of unnecessary files
          echo "Cleaning up unnecessary files..."
          find .deployment -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find .deployment -type d -name "tests" -exec rm -rf {} + 2>/dev/null || true
          find .deployment -type d -name "*.dist-info" -exec rm -rf {} + 2>/dev/null || true
          find .deployment -type d -name "*.egg-info" -exec rm -rf {} + 2>/dev/null || true
          find .deployment -type f -name "*.pyc" -delete 2>/dev/null || true
          find .deployment -type f -name "*.pyo" -delete 2>/dev/null || true
          # NOTE: *.so files must NOT be deleted ‚Äî pydantic_core and other C extensions
          # ship as compiled .so shared libraries and are required at runtime.

          # Remove test and documentation files
          find .deployment -type f -name "test_*.py" -delete 2>/dev/null || true
          find .deployment -type f -name "*_test.py" -delete 2>/dev/null || true
          find .deployment -type d -name "docs" -exec rm -rf {} + 2>/dev/null || true
          find .deployment -type d -name "examples" -exec rm -rf {} + 2>/dev/null || true

          # Copy application code
          cp -r app .deployment/
          cp function_app.py .deployment/
          cp host.json .deployment/
          cp requirements-azure.txt .deployment/requirements.txt

          # Clean up app __pycache__
          find .deployment/app -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true

          # Verify correct .so architecture
          SO_FILE=$(find .deployment -name '_pydantic_core*.so' | head -1)
          if [ -n "$SO_FILE" ]; then
            echo "‚úÖ pydantic_core: $(basename $SO_FILE)"
          else
            echo "‚ö†Ô∏è  pydantic_core .so not found ‚Äî package may be missing"
          fi

          # Create ZIP package with maximum compression
          cd .deployment
          zip -r9 -q ../function-app.zip .
          cd ..

          echo "‚úÖ Package created:"
          ls -lh function-app.zip
          PACKAGE_SIZE=$(du -h function-app.zip | cut -f1)
          PACKAGE_SIZE_KB=$(du -k function-app.zip | cut -f1)
          echo "üì¶ Package size: $PACKAGE_SIZE ($PACKAGE_SIZE_KB KB)"

          # Show size breakdown
          echo ""
          echo "üìä Top 10 largest items in package:"
          unzip -l function-app.zip | sort -k4 -n -r | head -n 11

      - name: Deploy Function App
        run: |
          FUNCTION_APP="${{ steps.pulumi_outputs.outputs.function_app_name }}"
          RESOURCE_GROUP="${{ steps.pulumi_outputs.outputs.resource_group_name }}"
          COSMOS_ACCOUNT="${{ steps.pulumi_outputs.outputs.cosmos_account_name }}"

          echo "üöÄ Deploying to Function App: $FUNCTION_APP"
          echo "üóÑÔ∏è  Cosmos DB Account: $COSMOS_ACCOUNT"

          # Check for ongoing deployments and wait if necessary
          echo "üîç Checking for ongoing deployments..."
          MAX_WAIT=300  # 5 minutes max wait
          WAIT_COUNT=0
          while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
            # Get deployment status from Kudu API
            DEPLOY_STATUS=$(az rest --method get \
              --url "https://${FUNCTION_APP}.scm.azurewebsites.net/api/deployments/latest" \
              --resource "https://management.azure.com/" \
              --query "status" -o tsv 2>/dev/null || echo "Unknown")
            
            if [ "$DEPLOY_STATUS" = "Running" ] || [ "$DEPLOY_STATUS" = "Building" ]; then
              echo "‚è≥ Deployment in progress (status: $DEPLOY_STATUS), waiting 30s..."
              sleep 30
              WAIT_COUNT=$((WAIT_COUNT+30))
            else
              echo "‚úÖ No ongoing deployment detected"
              break
            fi
          done

          if [ $WAIT_COUNT -ge $MAX_WAIT ]; then
            echo "‚ö†Ô∏è  Timeout waiting for previous deployment, proceeding anyway..."
          fi

          sleep 10  # Additional safety buffer

          # Get Cosmos DB endpoint and keys directly from Pulumi outputs
          echo "üîë Getting Cosmos DB credentials from Pulumi outputs..."
          COSMOS_ENDPOINT="${{ steps.pulumi_outputs.outputs.cosmos_db_endpoint }}"
          COSMOS_DATABASE="${{ steps.pulumi_outputs.outputs.cosmos_database_name }}"
          COSMOS_CONTAINER="${{ steps.pulumi_outputs.outputs.cosmos_container_name }}"
          COSMOS_ACCOUNT="${{ steps.pulumi_outputs.outputs.cosmos_account_name }}"

          # Get Cosmos DB key from Azure
          COSMOS_KEY=$(az cosmosdb keys list \
            --name $COSMOS_ACCOUNT \
            --resource-group $RESOURCE_GROUP \
            --type keys \
            --query primaryMasterKey -o tsv)

          if [ -z "$COSMOS_ENDPOINT" ] || [ -z "$COSMOS_KEY" ]; then
            echo "‚ùå Failed to retrieve Cosmos DB credentials"
            echo "   Endpoint: $COSMOS_ENDPOINT"
            echo "   Key: ${COSMOS_KEY:0:20}..."
            echo "   Account: $COSMOS_ACCOUNT"
            exit 1
          fi

          echo "‚úÖ Cosmos DB Account: $COSMOS_ACCOUNT"
          echo "‚úÖ Cosmos DB Endpoint: $COSMOS_ENDPOINT"

          # Get Front Door URL for CORS from Pulumi outputs
          FRONTDOOR_URL="${{ steps.pulumi_outputs.outputs.frontdoor_hostname }}"
          CORS_ORIGINS="https://${FRONTDOOR_URL},http://localhost:5173"
          # Include custom domain if set
          AZURE_CUSTOM_DOMAIN="${{ secrets.AZURE_CUSTOM_DOMAIN }}"
          if [ -n "$AZURE_CUSTOM_DOMAIN" ]; then
            CORS_ORIGINS="https://${AZURE_CUSTOM_DOMAIN},${CORS_ORIGINS}"
          fi

          echo "üîí CORS Origins: $CORS_ORIGINS"

          # Set Azure Functions platform-level CORS.
          # In Flex Consumption, Kestrel intercepts OPTIONS preflight BEFORE Python/FastAPI.
          # Platform CORS must include the allowed origins so Kestrel returns the required
          # Access-Control-Allow-Origin and Access-Control-Allow-Headers response headers.
          # NOTE: Kestrel returns CORS headers for origins that are explicitly listed here.
          #       It only responds to 'authorization' preflight headers (GET/non-body requests)
          #       and 'authorization+content-type' (POST requests with JSON body), which covers
          #       all browser use cases.
          echo "üîß Setting platform-level CORS origins..."
          # Build JSON array of allowed origins
          ORIGINS_JSON="["
          IFS=',' read -ra ORIGIN_ARRAY <<< "$CORS_ORIGINS"
          for i in "${!ORIGIN_ARRAY[@]}"; do
            if [ $i -gt 0 ]; then ORIGINS_JSON+=","; fi
            ORIGINS_JSON+="\"${ORIGIN_ARRAY[$i]}\""
          done
          ORIGINS_JSON+="]"
          az rest \
            --method PUT \
            --url "https://management.azure.com/subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${RESOURCE_GROUP}/providers/Microsoft.Web/sites/${FUNCTION_APP}/config/web?api-version=2022-03-01" \
            --body "{\"properties\":{\"cors\":{\"allowedOrigins\":${ORIGINS_JSON},\"supportCredentials\":false}}}" \
            2>/dev/null || echo "‚ö†Ô∏è  Could not set platform CORS (non-fatal)"

          # Remove existing CORS settings (both uppercase and lowercase)
          echo "üîß Removing existing CORS settings if present..."
          az functionapp config appsettings delete \
            --name $FUNCTION_APP \
            --resource-group $RESOURCE_GROUP \
            --setting-names CORS_ORIGINS cors_origins 2>/dev/null || true

          # Wait for delete to propagate
          sleep 3

          # Set environment variables (including Azure AD authentication)
          # Determine environment and auth settings
          DEPLOY_ENV="${{ steps.set_stack.outputs.stack_name }}"
          # AUTH_DISABLED must always be false to enforce auth guards on all environments
          AUTH_DISABLED_VALUE="false"

          echo "‚öôÔ∏è  Setting environment variables (ENVIRONMENT=$DEPLOY_ENV, AUTH_DISABLED=$AUTH_DISABLED_VALUE)..."
          az functionapp config appsettings set \
            --name $FUNCTION_APP \
            --resource-group $RESOURCE_GROUP \
            --settings \
              CLOUD_PROVIDER=azure \
              ENVIRONMENT="${DEPLOY_ENV}" \
              AUTH_DISABLED="${AUTH_DISABLED_VALUE}" \
              COSMOS_DB_ENDPOINT="${COSMOS_ENDPOINT}" \
              COSMOS_DB_KEY="${COSMOS_KEY}" \
              COSMOS_DB_DATABASE="${{ steps.pulumi_outputs.outputs.cosmos_database_name }}" \
              COSMOS_DB_CONTAINER="${{ steps.pulumi_outputs.outputs.cosmos_container_name }}" \
              AUTH_PROVIDER=azure \
              AZURE_TENANT_ID="${{ steps.azure_env.outputs.tenant_id }}" \
              AZURE_CLIENT_ID="${{ steps.pulumi_outputs.outputs.azure_ad_client_id }}" \
              CORS_ORIGINS="${CORS_ORIGINS}" \
              WEBSITE_WARMUP_PATH="/sns/health" \
              WEBSITE_KEEPALIVE_TIMEOUT="30" \
            > /dev/null

          # Disable HTTP/2 on Function App to prevent AFD stale TCP connection pool issue
          # AFD Standard uses HTTP/2 multiplexing which can hold stale streams after
          # Dynamic Consumption instance recycling, causing intermittent 502 errors
          az functionapp config set \
            --name $FUNCTION_APP \
            --resource-group $RESOURCE_GROUP \
            --http20 false \
            --output none

          echo "üîê Azure AD Authentication configured:"
          echo "  Tenant ID: ${{ steps.azure_env.outputs.tenant_id }}"
          echo "  Client ID: ${{ steps.pulumi_outputs.outputs.azure_ad_client_id }}"
          echo "üóÑÔ∏è  Cosmos DB configured:"
          echo "  Database: ${{ steps.pulumi_outputs.outputs.cosmos_database_name }}"
          echo "  Container: ${{ steps.pulumi_outputs.outputs.cosmos_container_name }}"

          echo "üì¶ Deploying function app package (with retry logic)..."

          # Retry deployment up to 3 times to handle Kudu restarts
          MAX_RETRIES=3
          RETRY_COUNT=0
          DEPLOY_SUCCESS=false

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Attempt $((RETRY_COUNT+1))/$MAX_RETRIES..."
            
            # Run deployment and capture output
            az functionapp deployment source config-zip \
              --resource-group $RESOURCE_GROUP \
              --name $FUNCTION_APP \
              --src services/api/function-app.zip \
              --timeout 600 \
              2>&1 | tee deploy_log.txt || true
            
            # Check for "another deployment in progress" error (retry with longer wait)
            if grep -q "another deployment is in progress" deploy_log.txt; then
              echo "‚è≥ Another deployment in progress, waiting 60s before retry..."
              RETRY_COUNT=$((RETRY_COUNT+1))
              sleep 60
              continue
            fi
            
            # Check for Kudu restart
            if grep -q "Kudu has been restarted" deploy_log.txt; then
              echo "üîÑ Kudu restart detected, retrying..."
              RETRY_COUNT=$((RETRY_COUNT+1))
              sleep 30
              continue
            fi
            
            # Check for successful deployment (in order of reliability)
            # 1. Explicit success message (most reliable for Flex Consumption)
            if grep -q "Deployment was successful" deploy_log.txt; then
              echo "‚úÖ Deployment successful!"
              DEPLOY_SUCCESS=true
              break
            # 2. Deployment steps completed (for other plan types)
            elif grep -q "UploadPackageStep.*completed" deploy_log.txt || \
                 grep -q "SyncTriggerStep" deploy_log.txt; then
              echo "‚úÖ Deployment steps completed!"
              DEPLOY_SUCCESS=true
              break
            # 3. Critical error (but not "partially successful" or "in progress")
            elif grep -q "ERROR:" deploy_log.txt && \
                 ! grep -q "partially successful" deploy_log.txt && \
                 ! grep -q "another deployment is in progress" deploy_log.txt; then
              echo "‚ùå Critical deployment error"
              cat deploy_log.txt
              exit 1
            else
              echo "‚ö†Ô∏è  Deployment status unclear, retrying..."
              RETRY_COUNT=$((RETRY_COUNT+1))
              sleep 30
            fi
          done

          if [ "$DEPLOY_SUCCESS" = false ]; then
            echo "‚ö†Ô∏è  Deployment uncertain after $MAX_RETRIES attempts, checking function health..."
          else
            echo "‚úÖ Deployment completed successfully!"
          fi

      - name: Enable Static Website Hosting
        run: |
          STORAGE_ACCOUNT="${{ steps.pulumi_outputs.outputs.frontend_storage_name }}"
          RESOURCE_GROUP="${{ steps.pulumi_outputs.outputs.resource_group_name }}"

          echo "üåê Enabling static website hosting on $STORAGE_ACCOUNT..."

          # Get storage account key
          STORAGE_KEY=$(az storage account keys list \
            --resource-group $RESOURCE_GROUP \
            --account-name $STORAGE_ACCOUNT \
            --query '[0].value' -o tsv)

          az storage blob service-properties update \
            --account-name $STORAGE_ACCOUNT \
            --account-key $STORAGE_KEY \
            --static-website \
            --index-document index.html \
            --404-document index.html

          # Configure Blob Storage CORS to allow direct image uploads from the app origins.
          # The frontend uploads images directly to $web/images container using SAS tokens,
          # so Blob Storage must allow CORS from both the custom domain and FrontDoor hostname.
          echo "üîí Configuring Blob Storage CORS for image uploads..."
          FRONTDOOR_HOSTNAME="${{ steps.pulumi_outputs.outputs.frontdoor_hostname }}"
          AZURE_CUSTOM_DOMAIN="${{ secrets.AZURE_CUSTOM_DOMAIN }}"

          # Clear existing CORS rules and re-add them fresh
          az storage cors clear \
            --account-name $STORAGE_ACCOUNT \
            --account-key $STORAGE_KEY \
            --services b

          # Add FrontDoor hostname rule
          az storage cors add \
            --account-name $STORAGE_ACCOUNT \
            --account-key $STORAGE_KEY \
            --services b \
            --origins "https://${FRONTDOOR_HOSTNAME}" \
            --methods PUT GET HEAD OPTIONS DELETE \
            --allowed-headers "*" \
            --exposed-headers "*" \
            --max-age 3600

          # Add custom domain rule if configured
          if [ -n "$AZURE_CUSTOM_DOMAIN" ]; then
            az storage cors add \
              --account-name $STORAGE_ACCOUNT \
              --account-key $STORAGE_KEY \
              --services b \
              --origins "https://${AZURE_CUSTOM_DOMAIN}" \
              --methods PUT GET HEAD OPTIONS DELETE \
              --allowed-headers "*" \
              --exposed-headers "*" \
              --max-age 3600
            echo "‚úÖ Blob Storage CORS: FrontDoor + custom domain (${AZURE_CUSTOM_DOMAIN})"
          else
            echo "‚úÖ Blob Storage CORS: FrontDoor only (no custom domain set)"
          fi

          # Add localhost for local development
          az storage cors add \
            --account-name $STORAGE_ACCOUNT \
            --account-key $STORAGE_KEY \
            --services b \
            --origins "http://localhost:5173" \
            --methods PUT GET HEAD OPTIONS DELETE \
            --allowed-headers "*" \
            --exposed-headers "*" \
            --max-age 3600

      - name: Build and Deploy Frontend
        run: |
          STORAGE_ACCOUNT="${{ steps.pulumi_outputs.outputs.frontend_storage_name }}"
          RESOURCE_GROUP="${{ steps.pulumi_outputs.outputs.resource_group_name }}"
          FRONTDOOR_HOSTNAME="${{ steps.pulumi_outputs.outputs.frontdoor_hostname }}"
          API_URL="${{ steps.pulumi_outputs.outputs.api_url }}"
          AZURE_CLIENT_ID="${{ steps.pulumi_outputs.outputs.azure_ad_client_id }}"
          AZURE_TENANT_ID="${{ steps.azure_env.outputs.tenant_id }}"
          # Use custom domain if set, fall back to FrontDoor hostname
          AZURE_CUSTOM_DOMAIN="${{ secrets.AZURE_CUSTOM_DOMAIN }}"
          AZURE_PUBLIC_HOST="${AZURE_CUSTOM_DOMAIN:-${FRONTDOOR_HOSTNAME}}"

          echo "üèóÔ∏è  Building React frontend for Azure..."
          echo "üåê Using public host for redirect URIs: ${AZURE_PUBLIC_HOST}"
          cd services/frontend_react

          # Install dependencies
          npm ci --prefer-offline

          # Build with Azure-specific env vars
          VITE_AUTH_PROVIDER=azure \
          VITE_API_URL="${API_URL}" \
          VITE_AZURE_TENANT_ID="${AZURE_TENANT_ID}" \
          VITE_AZURE_CLIENT_ID="${AZURE_CLIENT_ID}" \
          VITE_AZURE_REDIRECT_URI="https://${AZURE_PUBLIC_HOST}/sns/auth/callback" \
          VITE_AZURE_LOGOUT_URI="https://${AZURE_PUBLIC_HOST}/sns/" \
          VITE_BASE_PATH=/sns/ \
          npm run build

          echo "‚úÖ Frontend build complete. Uploading to Azure Blob Storage..."
          cd ../..

          # Get storage account key
          STORAGE_KEY=$(az storage account keys list \
            --resource-group $RESOURCE_GROUP \
            --account-name $STORAGE_ACCOUNT \
            --query '[0].value' -o tsv)

          # Upload built files to $web/sns/ (Front Door SPA route: /sns/* ‚Üí $web/sns/)
          # VITE_BASE_PATH=/sns/ means index.html references /sns/assets/...
          # but the actual output files are in dist/ (flat), so upload to $web/sns/
          az storage blob upload-batch \
            --account-name $STORAGE_ACCOUNT \
            --account-key $STORAGE_KEY \
            --source services/frontend_react/dist \
            --destination '$web/sns' \
            --overwrite

          # Copy public SVG files to sns/assets/ as well (CSS references ./file.svg
          # relative to /sns/assets/, so they must exist at /sns/assets/file.svg)
          for svg_file in services/frontend_react/dist/*.svg; do
            [ -f "$svg_file" ] || continue
            svg_name=$(basename "$svg_file")
            az storage blob upload \
              --account-name $STORAGE_ACCOUNT \
              --account-key $STORAGE_KEY \
              --container-name '$web' \
              --file "$svg_file" \
              --name "sns/assets/${svg_name}" \
              --content-type "image/svg+xml" \
              --overwrite > /dev/null 2>&1 && echo "‚úÖ Uploaded sns/assets/${svg_name}"
          done

          echo "‚úÖ Frontend uploaded to Azure Blob Storage"
          echo "üåê Frontend URL: https://${FRONTDOOR_HOSTNAME}/sns/"

      - name: Verify Deployment
        run: |
          FUNCTION_APP="${{ steps.pulumi_outputs.outputs.function_app_name }}"
          RESOURCE_GROUP="${{ steps.pulumi_outputs.outputs.resource_group_name }}"

          echo "üîç Verifying API deployment..."
          echo "Getting Function App hostname..."

          # Get hostname - for Flex Consumption plan, use config hostname list
          # (defaultHostName is not reliable for Flex Consumption SKU)
          max_hostname_attempts=10
          hostname_attempt=0
          FUNC_HOSTNAME=""

          while [ $hostname_attempt -lt $max_hostname_attempts ]; do
            FUNC_HOSTNAME=$(az functionapp config hostname list \
              --webapp-name $FUNCTION_APP \
              --resource-group $RESOURCE_GROUP \
              --query '[0].name' -o tsv 2>/dev/null || echo "")
            
            if [ -n "$FUNC_HOSTNAME" ] && [ "$FUNC_HOSTNAME" != "None" ]; then
              echo "‚úÖ Got hostname: $FUNC_HOSTNAME"
              break
            else
              echo "‚è≥ Waiting for Function App to be ready... (attempt $((hostname_attempt+1))/$max_hostname_attempts)"
              sleep 10
              hostname_attempt=$((hostname_attempt+1))
            fi
          done

          if [ -z "$FUNC_HOSTNAME" ] || [ "$FUNC_HOSTNAME" = "None" ]; then
            echo "‚ùå Failed to get Function App hostname after waiting"
            echo "Try checking manually: az functionapp config hostname list --webapp-name $FUNCTION_APP --resource-group $RESOURCE_GROUP"
            exit 1
          fi

          FUNC_URL="https://${FUNC_HOSTNAME}/api/HttpTrigger"
          echo "Testing: ${FUNC_URL}/health"

          # Wait for function to be ready (max 3 minutes)
          max_attempts=36
          attempt=0
          health_check_passed=false

          while [ $attempt -lt $max_attempts ]; do
            if response=$(curl -sf "${FUNC_URL}/health" 2>&1); then
              echo "‚úÖ API is responding!"
              echo "$response" | jq .
              health_check_passed=true
              break
            else
              echo "‚è≥ Waiting for function to be ready... (attempt $((attempt+1))/$max_attempts)"
              sleep 5
              attempt=$((attempt+1))
            fi
          done

          if [ "$health_check_passed" = true ]; then
            echo ""
            echo "‚úÖ Azure Function deployment verified successfully!"
            echo "üìç API URL: ${FUNC_URL}"
          else
            echo ""
            echo "‚ùå Health check failed after waiting for $((max_attempts * 5)) seconds"
            echo "This may be a transient issue. Check manually: ${FUNC_URL}/health"
            exit 1
          fi

      - name: Notify Success
        if: success()
        run: |
          echo "‚úÖ Azure deployment succeeded!"
          echo "üìç API URL: ${{ steps.pulumi_outputs.outputs.api_url }}"
          echo "üåê Frontend Storage: ${{ steps.pulumi_outputs.outputs.frontend_storage_name }}"

      - name: Notify Failure
        if: failure()
        run: echo "‚ùå Azure deployment failed!"
